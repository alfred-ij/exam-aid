---
title: "Fundamentals of Long-Term Actuarial Modeling"
subtitle: ExaminationAid® Series
output:
  pdf_document: default
  html_document:
    df_print: paged
---
```{css, echo=FALSE}
h1, h2, h3, h4 {
  text-align: center;
}
figure {
  margin-left: auto;
  margin-right: auto;
}
```{r libraries & class objects,warning=FALSE,error=FALSE,message=FALSE,include=FALSE}
library(dplyr) #df manipulation
library(ggplot2) #plotting 
library(kableExtra); library(knitr) #knitting
library(tidyverse) #df manipulation
library(methods) # class structure
library(Dict) #dictionary
library(latex2exp) #latex text
library(tinsel) #decorator functions
library(tidyr) #df manipulation
source('~/Library/Mobile Documents/com~apple~CloudDocs/Documents/mini/projects/soaFAM/R/discreteProbs.R')
source('~/Library/Mobile Documents/com~apple~CloudDocs/Documents/mini/projects/soaFAM/R/discreteProducts.R')
```

# §1: Introduction 
## §1.1: Abstract
This research proposal, titled "Fundamentals of Long-Term Actuarial Modeling," aims to integrate traditional actuarial practices with modern data science techniques through the application of object-oriented programming (OOP) principles in R. Inspired by insights from the Long-Term Actuarial Mathematics (LTAM) course and extensive professional experience in data science, this project presents a practical application of OOP in actuarial science. The proposal will illustrate how leveraging OOP concepts such as classes, objects, and inheritance can transform actuarial modeling by enhancing the modularity, reusability, and scalability of models.

Focusing on practical implementations in R, the proposal will use actuarial concepts from FAM-L to explain key programming principles like functions, algorithms, and plotting. The research demonstrates how to develop sophisticated data products that efficiently handle complex data sets, providing an alternative to traditional methods such as Excel tables. This approach serves as a foundation for developing innovative educational and professional tools, contributing to the Actuarial Science CRAN community, and leading to the eventual creation of comprehensive exam aid dashboards tailor made for the actuarial science industry and participants.

The findings and methodologies will be detailed in the succeeding sections of the proposal, showcasing real-world examples, case studies, and the practical application of OOP techniques in actuarial projects. This research ultimately aims to enhance actuarial workflows and foster greater collaboration within actuarial teams.

## §1.2: Content Overview
### §1.2.1 FAM-L Content
This proposal delves into the essential relationships between survival models, life tables, insurance benefits, annuities, and profitability, following a progression that mirrors the structure of "Actuarial Mathematics for Life Contingent Risks."

- **Chapter 2**: Survival Models

  - Survival models form the foundational basis for actuarial science, describing the distribution of time until events such as death. These models employ functions like the survival function and hazard function, which are crucial for understanding mortality trends. This understanding is essential for predicting lifespans and informing the design of life-contingent products.

- **Chapter 3**: Life Tables

  - Life tables, derived from survival models, provide empirical data on mortality rates and survival probabilities at various ages. They are indispensable tools for actuaries, offering critical insights that inform the creation and pricing of insurance policies and annuities by illustrating the likelihood of survival across different age groups.

- **Chapter 4**: Insurance Benefits

  - Insurance benefits are calculated by integrating survival probabilities to ensure adequate coverage. These benefits are designed based on the empirical data from life tables, ensuring that payouts are financially viable and meet the needs of policyholders. Accurate determination of present values for future payouts is crucial for the sustainability of insurance products.

- **Chapter 5**: Annuities

  - Annuities provide regular payments over the lifetime of the annuitant and rely heavily on survival models and life tables for valuation. Different types of annuities (immediate, deferred, fixed, and variable) each require precise calculation of expected present values to ensure they provide sufficient income streams while being financially sustainable.

- **Chapter 6**: Profitability (Policy Values)

  - Profitability in insurance products is assessed through policy values, which are the present values of future cash flows, including premiums and benefits. Actuarial models use survival probabilities, discount rates, and expense assumptions to determine these values. A profitable policy ensures that the present value of premiums surpasses the present value of benefits and expenses, thus ensuring the insurer's financial health.

The progression from survival models to profitability illustrates the integrated nature of actuarial science. Each chapter builds on the previous, from understanding mortality trends and using this knowledge to design viable insurance products, to ultimately ensuring these products are profitable. This comprehensive approach ensures the development of robust insurance and financial products that meet individual needs and support the financial stability of insurance companies.

### §1.2.2 R-Programming Content
To achieve the goals outlined in the abstract and the overview, this proposal employs a variety of R programming techniques, catering to users of all skill levels—from novices to experts. These techniques demonstrate how R can be effectively utilized in professional environments to handle a range of actuarial tasks and situations.

#### §1.2.2.1 Novice and Intermediate Users

- **Plotting with ggplot2**: This powerful visualization package allows users to create complex and informative plots. Novices can start with basic plots, while intermediates can explore advanced customization and data visualization techniques, making it easier to communicate insights from actuarial data effectively.

- **Data-Frame Manipulation with dplyr and tidyverse**: These packages streamline data manipulation, enabling users to filter, arrange, and summarize data efficiently. Novices will learn the basics of data manipulation, and intermediates can leverage these tools for more sophisticated data wrangling tasks, essential for preparing actuarial data sets for analysis.

- **Algorithms with if-else Statements**: Basic conditional logic using if-else statements allows users to implement simple decision-making processes in their code. This foundational programming concept helps in automating repetitive tasks and is crucial for actuarial calculations and data analysis.

#### §1.2.2.2 Intermediate and Advanced Users

- **Algorithms with for-loop Statements**: For-loop statements enable the execution of repetitive tasks over a sequence of elements. Intermediate users will learn to iterate over data sets, performing complex calculations, and advanced users can optimize these loops for efficiency, crucial for handling large actuarial data sets.

- **Functional Programming with sapply**: The sapply function applies a function to each element of a list or vector, simplifying code and making it more readable. This concept introduces functional programming principles, which are beneficial for performing repetitive actuarial computations and data transformations.

- **Object-Oriented Programming with S4 Class Objects**: S4 class objects represent a robust OOP system in R, allowing for the creation of complex data structures. Advanced users will learn to design and implement reusable and scalable actuarial models, enhancing the modularity and maintainability of their code.

#### §1.2.2.3 Application in Professional Environments

- **Plotting**: Actuaries can create detailed visualizations of survival models and life tables, aiding in the presentation and interpretation of mortality trends and insurance benefits.

- **Data-Frame Manipulation**: Efficient data manipulation is crucial for preparing data for actuarial analysis, including calculating annuity values and policy profitability.

- **Algorithms**: Conditional logic and loop constructs automate the process of evaluating insurance policies and annuities, ensuring accuracy and efficiency.

- **Functional Programming**: Simplifies complex actuarial computations, making code easier to maintain and extend.

- **Object-Oriented Programming**: Facilitates the development of sophisticated actuarial models that are modular and reusable, supporting long-term maintenance and scalability.

By integrating these R techniques, this proposal not only achieves the goals set out in the abstract and overview but also equips users with the necessary skills to apply these concepts in diverse professional settings, enhancing their ability to develop robust and efficient actuarial solutions.

### §1.2.3: Mortality parameters
Unless explicitly stated otherwise, the mortality parameters for both the ultimate and select periods used in this proposal follow the definitions provided in Appendix D of the textbook "Actuarial Mathematics for Life Contingent Risks" (Third Edition) by Dickson, Hardy, and Waters.

  - **Law**: 
    - \( Name \): Makeham
    - \( Formula \): 
        \[
          \mu_x = A + Bc^x
        \]
        
        where 
        
        \[
          \mu_x = \text{Standard Ultimate Survival Model},
        \]
        \[
          A = \text{constant representing age-independent mortality},
        \]
        \[
          B = \text{constant representing age-dependent mortality factors},
        \]
        \[
          c = \text{constant representing age-dependent mortality factors}.
        \]
                
  - **Parameters**:
    - \( A \): 0.00022
    - \( B \): 0.0000027
    - \( c \): 1.124
    
  - **Select Period**: 
    - \( Duration \): 2 years $(0 \leq s \leq 2)$
    - \( Formula \):
        \[
          \mu_{[x]+s} = 0.9^{2-s} \mu_{x+s}
        \]
        
        where 
        
        \[
          \mu_{[x]+s} = \text{Standard Select Survival Model},
        \]
        \[
          \mu_{x+s} = \text{force of mortality at age } (x+s).
        \]
    
    
  - **Interest Rate**:
    - \( i\): 5%

# §2: Body
The body of this proposal examines the key relationships among survival models, life tables, insurance benefits, annuities, and profitability, structured similarly to "Actuarial Mathematics for Life Contingent Risks." It begins with survival models, which are fundamental for predicting mortality trends and designing life-contingent products. Next, life tables provide empirical data on mortality rates, essential for creating and pricing insurance policies and annuities. Insurance benefits are then calculated using survival probabilities to ensure financial viability. Annuities are valued based on these models and tables to provide sustainable income streams. Finally, the profitability of insurance products is assessed through policy values, ensuring that premiums exceed benefits and expenses. Each section builds on the previous one, illustrating the integrated nature of actuarial science and its role in developing robust financial products.
    
## §2.1: Survival Models

Survival models are the cornerstone of actuarial science, describing the distribution of time until events such as death. These models use functions like the survival function and hazard function, which are critical for understanding mortality trends. This knowledge is essential for predicting lifespans and designing life-contingent products.
  
### §2.1.1: Gompertz Survival Model

The R code snippet for the Gompertz survival model demonstrates several key R concepts. Using ggplot2, it creates complex and informative plots to visualize survival probabilities and future lifetime probability density functions for ages 20, 50, and 80. The dplyr and tidyverse packages streamline data manipulation, allowing for efficient filtering, arranging, and summarizing of data, which is essential for actuarial analysis. Basic if-else statements implement conditional logic for simple decision-making processes. For-loop statements execute repetitive tasks over data sequences, with intermediate users learning iteration for complex calculations and advanced users optimizing for efficiency. The sapply function introduces functional programming principles, applying functions to list or vector elements to simplify code. Additionally, S4 class objects enable the creation of complex data structures, allowing advanced users to design reusable and scalable actuarial models, enhancing code modularity and maintainability.

Code: `example 2.4: Gompertz survival model appendix`

```{r example 2.4: Gompertz survival model,fig.align='center',fig.height=3, echo=FALSE}
#example 2.4: Gompertz survival model 
#-------------------------------------------------------------------------------code
#discrete life ages
age_list <- list(20,50,80) 
#mortality parameters
B <- .0003; c <- 1.07 
#initialize discreteProbs object
probFunc1 <- discreteProbs$new(
  #age distribution range
  age_range=list(0,120), 
  #mortality law
  mort_law='Gompertz', 
  #mortality parameters
  other_params=list(B,c)) 
#initialize t_p_x plots
tempPlot1 <- ggplot() 
#initialize t_f_x plots
tempPlot2 <- ggplot() 
#create unique plots per life age (x)
for(x in age_list){ 
  #create data frame with desired probabilities...initialize future ages...max age of 120
  tempData <- data.frame(age=c(0:(120-(x+1)))) %>% 
    #compute survival probability...t_p_x
    mutate(p=sapply(age, probFunc1$p_x_t, x=x)) %>% 
    #compute future life-time pdf...t_f_x
    mutate(f=sapply(age, probFunc1$f_x_t, x=x)) %>% 
    #assign age (x) indicator from age_list
    mutate(age_x=factor(x))  
  #add computed values to plots
  #plot t_p_x for age (x)
  tempPlot1 <- tempPlot1 + geom_point(data=tempData, aes(age, p, colour=age_x)) 
  #plot t_f_x for age (x)
  tempPlot2 <- tempPlot2 + geom_point(data=tempData, aes(age, f, colour=age_x)) 
}
#customize plots
#define color scheme for plot legend
cols <- c("20" = "blue", "50" = "red", "80" = "grey") 
tempPlot1 <- tempPlot1 +
             labs( 
               title='Discrete Future Life-time Distribitions',
               x = TeX(r'(Number of Discrete Future Periods $\left{\sum_{k=0}^{\omega-(x+1)}\right}$)'),
               y = TeX(r'($S_{x}(t)$)'),
               subtitle = "Based on: Gompertz's Law of Mortality (example 2.4)",
               color='Life Age (x)'
             ) +
             theme_dark() +
             theme(plot.title = element_text(hjust = 0.5)) +
             theme(plot.subtitle = element_text(hjust = 0.5)) + 
             scale_colour_manual(values = cols) 
tempPlot2 <- tempPlot2 +
             labs( 
               title='Discrete Future Life-time Distribitions',
               x = TeX(r'(Number of Discrete Future Periods $\left{\sum_{k=0}^{\omega-(x+1)}\right}$)'),
               y = TeX(r'($f_{x}(t)$)'),
               subtitle = "Based on: Gompertz's Law of Mortality (example 2.4)",
               color='Life Age (x)'
             ) +
             theme_dark() +
             theme(plot.title = element_text(hjust = 0.5)) +
             theme(plot.subtitle = element_text(hjust = 0.5)) + 
             scale_colour_manual(values = cols)
#display plots
print(tempPlot1); print(tempPlot2)
```

### §2.1.2: Complete Future Life-Time

This R code snippet calculates and visualizes the complete future lifetime distribution based on Gompertz's Law of Mortality for ages ranging from 0 to 100 in increments of 10. Using the `discreteProbs` class, the code initializes mortality parameters $(B)$ and $(c)$ and sets the maximum age $(\omega)$ to 130. It iterates over the specified age list, computing the survival probabilities $_tp_x$ for each age, and accumulates these probabilities to calculate the complete future lifetime $e_x$ and the adjusted complete future lifetime $e^{o}_x$. The results are then compiled into a data frame and plotted using `ggplot2` to display the discrete complete future lifetime distribution. The plot is customized with titles, subtitles, and axis labels, and the final results are displayed both as a plot and a formatted table using `knitr::kable`.

Code: `table 2.2: complete future life-time appendix`

```{r table 2.2: complete future life-time,fig.align='center',fig.height=3.5,echo=FALSE,warning=FALSE}
#table 2.2: complete future life-time 
#-------------------------------------------------------------------------------code
#desired ages
age_list <- seq(0,100,10) 
#mortality parameters
B <- .0003; c <- 1.07; omega <- 130 
#initialize discreteProbs object
probFunc2 <- discreteProbs$new(
  #age distribution range
  age_range=list(0,omega), 
  #mortality law
  mort_law='Gompertz',
  #mortality parameters
  other_params=list(B,c)) 
#create base data frame with desired figures
#initialize discrete list
e_x_list <- list() 
#initialize continuous list
e_o_x_list <- list() 
#perform iterations per age in input list
for (x in age_list){ 
  #setup distribution age range
  table2_2_1 <- data.frame(age=c(1:(omega-(x+1)))) %>% 
    #compute t_p_x
    mutate(p=sapply(age, probFunc2$p_x_t, x=x)) 
  #compute and append e_x to e_x_list per x
  e_x_list <- append(e_x_list,sum(table2_2_1$p)) 
  #compute and append e_o_x to e_o_x_list per x
  e_o_x_list <- append(e_o_x_list,(sum(table2_2_1$p)+0.5)) 
}
#plot results
table2_2_2 <- data.frame( 
  #define table output...age_x || e_x || e_o_x
  age_x = age_list,
  e_x = unlist(e_x_list),
  e_o_x = unlist(e_o_x_list)
)
plot2_2 <- ggplot(data=table2_2_2) +
  geom_point(aes(x=age_x,y=e_x))+
  labs(
       title='Discrete Complete Future Life-time Distribition',
       x = 'Life Age (x)',
       y = TeX(r'($e_{x}$)'),
       subtitle = "Based on: Gompertz's Law of Mortality (table 2.2)"
     ) +
   theme_dark() +
   theme(plot.title = element_text(hjust = 0.5)) +
   theme(plot.subtitle = element_text(hjust = 0.5)) +
   scale_colour_manual(values = cols)
print(plot2_2); knitr::kable(table2_2_2, align = "c")
```

## §2.2: Life-Tables

Life tables, derived from survival models, provide empirical data on mortality rates and survival probabilities at various ages. They are vital tools for actuaries, offering crucial insights that inform the creation and pricing of insurance policies and annuities by illustrating survival likelihoods across different age groups.
 
### §2.2.1: Select & Ultimate Life-Tables

This R code snippet extends the concepts from earlier sections on survival models to calculate and visualize select and ultimate life-tables for ages 20 to 110 using Gompertz's Law of Mortality. Building on survival probabilities, it initializes mortality parameters and sets an interest rate, then employs the discreteProbs class to generate life-table values. The code iterates over select periods, computing survival probabilities and life-table values for each period, demonstrating the dependency on previously established survival models. It calculates pure endowment values for terms of 5, 10, and 20 years, adjusting based on whether the term falls within the select or ultimate period. The results, which showcase survival probabilities and life-table values, are compiled into a data frame and formatted for presentation, filtered for specific age ranges, and displayed using `knitr::kable`.

Code: `table 3.1: ultimate life-table appendix`

```{r table 3.1: ultimate life-table,fig.align='center',echo=FALSE}
#table 3.1: ultimate life-table
#-------------------------------------------------------------------------------code
d <- 2; age_list <- list(20,110); i <- .05; v <- 1/(1+i)
radix <- 10^5; terms <- c(5,10,20)
probFunc3 <- discreteProbs$new()
#create data frame with desired life-table values
#define age range
table_3_7_1 <- data.frame(age_x=c((age_list[[1]]-d):age_list[[2]])) %>% 
  #define ultimate period age
  mutate(!!paste('age+',d,sep=''):=age_x+d) %>% 
  #define ultimate period life-table value
  mutate(!!paste('l_x+',d,sep=''):=sapply(!!sym(paste('age+',d,sep='')),
                                          probFunc3$lt_x_t,t=0,
                                          radix=radix,
                                          x0=age_list[[1]])) 
  for(select in c(1:d)){ 
    #loop through periods
    temp_name <- paste("p_[x]_",select,sep='') 
    #initialize survival feature name
    table_3_7_1 <- table_3_7_1 %>%
      #compute select period survival probabilities
      mutate(!!temp_name:=sapply(age_x,probFunc3$select_p_x_t,t=select,d=d)) 
    if (select > 1){ #setup period survival probabilities
      #initialize survival feature name...select-1
      previous_temp_name <- paste("p_[x]_",select-1,sep='') 
      #initialize survival feature name...select
      current_temp_name <- paste("p_[x]_",select,sep='') 
      #initialize survival feature name...select-1
      new_p_name <- paste("p_[x]+",select-1,"_1",sep='') 
      #initialize life-table feature name...select
      new_l_name <- paste("l_[x]+",select-1,sep='') 
      table_3_7_1 <- table_3_7_1 %>%
        #compute survival probabilities
        mutate(!!new_p_name:= !!sym(current_temp_name) / !!sym(previous_temp_name)) %>% 
        #compute life-table values
        mutate(!!new_l_name:= !!sym(paste('l_x+',d,sep=''))/!!sym(new_p_name)) 
      table_3_7_1[1:d,new_l_name] <- NA
    }
    if (select == d){
      #initialize life-table feature name
      l_name <- 'l_[x]' 
      table_3_7_1 <- table_3_7_1 %>%
        #compute life-table values
        mutate(!!l_name := !!sym(paste('l_x+',d,sep=''))/!!sym(paste("p_[x]_",select,sep=''))) 
      table_3_7_1[1:d,l_name] <- NA
    }
  }
#compute varying select pure endowment
for(term in terms){
  if(term < d){ #within select period
    temp_numerator <- 'l_[x]'
    lag_level <- term
  }else if(term >= d){ #within ultimate period
    temp_numerator <- paste('l_x+',d,sep='')
    lag_level <- term - d
  }
  temp_denominator <- 'l_[x]'
  temp_list <- list()
  table_3_7_1 <- table_3_7_1 %>%
    mutate(!!paste(term,'_E_[x]',sep=''):=(v^term)*lead(!!sym(temp_numerator),lag_level)/!!sym(temp_denominator))
  }
#query output
table_3_7_2 <- table_3_7_1 %>%
  #filter columns
  select(c('age+2','l_x+2','age_x','l_[x]+1','l_[x]','5_E_[x]','10_E_[x]','20_E_[x]')) %>%
  filter(age_x %in% c((age_list[[1]]-d):(age_list[[1]]+15),(80-15):80))
knitr::kable(table_3_7_2, align = "c")
```

## §2.3: Insurance Benefits

Insurance benefits are calculated by integrating survival probabilities to ensure adequate coverage. These benefits are based on empirical data from life tables, ensuring that payouts are financially viable and meet policyholders' needs. Accurately determining the present values of future payouts is crucial for the sustainability of insurance products.
  
### §2.3.1: Discrete Insurance Benefits

This R code snippet continues the exploration of survival models by focusing on discrete insurance benefits. Building on earlier sections, it calculates and compares insurance benefits for various ages (30 to 32, 50 to 52, and 98 to 100) and monthly schedules (1, 4, 12, and 365 months). Using the `discreteProducts` class and an interest rate of 5%, it initializes product objects and computes whole life insurance benefit values for each age and monthly schedule. The results, showcasing insurance benefits for different age groups and schedules, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This demonstrates the application of survival models to determine insurance benefits, highlighting their role in actuarial calculations and product development.

Code: `table 4.1: insurance benefits comparison appendix`

```{r table 4.1: insurance benefits comparison,fig.align='center',echo=FALSE}
#table 4.1: insurance benefits
#-------------------------------------------------------------------------------code
#define m_thly schedules
m_list <- c(1,4,12,365) 
#define interest rate and annuity schedule
i <- .05; annuity_schedule <- 'Due' 
#define age list
age_list <- c(30:32,50:52,98:100) 
#initialize output table
table_4_1_1 <- data.frame(age_x=age_list) 
for(m_th in m_list){
  #initialize product object
  tempPB <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th) 
  table_4_1_1 <- table_4_1_1 %>%
    #compute whole life insurance benefit values
    mutate(!!paste('A_x_(',m_th,')',sep=''):=sapply(age_x,tempPB$whole_A_x,moment=1)) 
}
table_4_1_2 <- table_4_1_1 %>%
  #filter columns
  select(!contains('p')) 
knitr::kable(table_4_1_2, align = "c")
```

### §2.3.2: M-thly Insurance Benefits

Expanding upon the previous sections on insurance benefits, this R code snippet focuses on m-thly insurance benefits. It calculates and compares insurance benefits for ages spanning from 20 to 21, 50 to 51, and 127 to 128, using a monthly schedule of 12 months, an interest rate of 5%, and an annuity schedule of 'Due'. Utilizing the `discreteProducts` class, the code initializes product objects and computes probabilities $_tp_x$ and $_tq_x$ as well as whole-life insurance benefit values $A_x$ for each age. The results, illustrating insurance benefits for different age groups and monthly schedules, are organized into a data frame and presented as a comparison table using `knitr::kable`. This underscores the application of survival models in determining insurance benefits and underscores their significance in actuarial calculations and product evaluation.

Code: `table 4.2: m-thly insurance benefits appendix`

```{r table 4.2: m-thly insurance benefits,fig.align='center',echo=FALSE}
#table 4.2: insurance benefits
#-------------------------------------------------------------------------------code
#define m_thly schedule, interest rate, and annuity schedule
m_th <- 12; i <- .05; annuity_schedule <- 'Due' 
#define ages
age_list <- c(seq(20,21,1/m_th),seq(50,51,1/m_th),seq(127,128,1/m_th)) 
#define products class
productFun1 <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th) 
table_4_2_1 <- data.frame(age_x=age_list) %>%
  #compute t_p_x
  mutate('p_x_(12)'=sapply(age_x,productFun1$p_x_t,t=1)) %>% 
  #compute t_q_x
  mutate('q_x_(12)'=sapply(age_x,productFun1$q_x_t,t=1)) %>% 
  #compute whole-life probability
  mutate('A_x_(12)'=sapply(age_x,productFun1$whole_A_x,moment=1)) 
knitr::kable(table_4_2_1, align = "c")
```

### §2.3.3: Mean & Variance of Insurance Benefit EPVs

Building upon the previous sections on insurance benefits, this R code snippet focuses on calculating the mean and standard deviation of insurance benefit EPVs (Equivalent Present Values). It considers m-thly schedules (1, 4, and 12), an interest rate of 5%, and an annuity schedule of 'Due'. Age ranges from 20 to 100, with a benefit value $S$ set at $10^5$. The code initializes product objects for each m-thly variation using the `discreteProducts` class and computes the first and second moments of insurance benefit EPVs. It then calculates the mean and standard deviation using these moments. The results, demonstrating the mean and standard deviation for each age and m-thly schedule, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This underscores the application of survival models in assessing the variability of insurance benefit EPVs and their significance in actuarial calculations and risk analysis.

Code: `table 4.3: mean and standard deviation of insurance benefit EPV appendix`

```{r table 4.3: mean and standard deviation of insurance benefit EPV,fig.align='center',echo=FALSE}
#table 4.3: mean and standard deviation of insurance benefit EPV
#-------------------------------------------------------------------------------code
#define m_thly schedules, interest rate, and annuity schedule
m_list <- c(1,4,12); i <- .05; annuity_schedule <- 'Due' 
#define ages and benefit value
age_list <- seq(20,100,20); S <- 10^5 
#initialize output table
table_4_3_1 <- data.frame(age_x=age_list) 
for(m_th in m_list){
  #define case product object...m_th variation
  productFun2 <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th) 
   table_4_3_1 <- table_4_3_1 %>%
    #compute first moment
    mutate(!!paste('A_x_(',m_th,')',sep=''):=sapply(age_x,productFun2$whole_A_x,moment=1)) %>% 
    #compute second moment
    mutate(!!paste('2_A_x_(',m_th,')',sep=''):=sapply(age_x,productFun2$whole_A_x,moment=2)) %>% 
    #compute mean
    mutate(!!paste('mean_A_x_(',m_th,')',sep=''):=S*!!sym(paste('A_x_(',m_th,')',sep=''))) %>% 
    #compute standard deviation
    mutate(!!paste('std_x_(',m_th,')',sep=''):=S*sqrt(!!sym(paste('2_A_x_(',m_th,')',sep=''))-
                                                        (!!sym(paste('A_x_(',m_th,')',sep=''))*
                                                           !!sym(paste('A_x_(',m_th,')',sep=''))))) 
}
table_4_3_2 <- table_4_3_1 %>%
  #collect age, mean, and std columns
  select(contains(c('age','mean','std'))) 
knitr::kable(table_4_3_2, align = "c")
```

### §2.3.4: Term Insurance Benefits

Expanding on the analysis of insurance benefits, this R code snippet focuses specifically on term insurance benefits. It calculates term insurance benefits for ages ranging from 20 to 100 and for term periods of 10 years. Utilizing m-thly schedules of 1, 4, and 12, an interest rate of 5%, and an annuity schedule of 'Due', the code initializes product objects for each m-thly variation using the `discreteProducts` class. It then computes term insurance benefits for each age and m-thly schedule. The results, illustrating term insurance benefits for different age groups and m-thly schedules, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This demonstrates the application of survival models in determining term insurance benefits and underscores their importance in actuarial calculations and risk management.

Code: `table 4.4: term insurance benefits appendix`

```{r table 4.4: term insurance benefits,fig.align='center',echo=FALSE}
#table 4.4: term insurance benefits
#-------------------------------------------------------------------------------code
#define m_thly schedules, interest rate, and annuity schedule
m_list <- c(1,4,12); i <- .05; annuity_schedule <- 'Due' 
#define ages and term period
age_list <- seq(20,100,20); term <- 10
#initialize output table
table_4_4_1 <- data.frame(age_x=age_list) 
for(m_th in m_list){
  #define case product object...m_th variation
  productFun3 <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th) 
  table_4_4_1 <- table_4_4_1 %>%
    #compute term insurance benefit
    mutate(!!paste('A_x´_',term,'_(',m_th,')',sep=''):=sapply(age_x,productFun3$term_A_x,moment=1,n=term))
}
knitr::kable(table_4_4_1, align = "c")
```

### §2.3.5: Endowment Insurance Benefits

This R code snippet delves into the analysis of endowment insurance benefits. It calculates endowment insurance benefits for ages ranging from 20 to 100 and for a term period of 10 years. Employing m-thly schedules of 1, 4, and 12, an interest rate of 5%, and an annuity schedule of 'Due', the code initializes product objects for each m-thly variation using the `discreteProducts` class. It then computes endowment insurance benefits for each age and m-thly schedule. The resulting benefits, representing different age groups and m-thly schedules, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This highlights the application of survival models in determining endowment insurance benefits and underscores their significance in actuarial calculations and financial planning.

Code: `table 4.5: endowment insurance benefits appendix`

```{r table 4.5: endowment insurance benefits,fig.align='center',echo=FALSE}
#table 4.5: endowment insurance benefits
#-------------------------------------------------------------------------------code
#define m_thly schedules, interest rate, and annuity schedule
m_list <- c(1,4,12); i <- .05; annuity_schedule <- 'Due' 
#define ages and term period
age_list <- seq(20,100,20); term <- 10
#initialize output table
table_4_5_1 <- data.frame(age_x=age_list) 
for(m_th in m_list){
  #define case product object...m_th variation
  productFun4 <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th) 
  table_4_5_1 <- table_4_5_1 %>%
    #compute endowment insurance benefit
    mutate(!!paste('A_x_',term,'_(',m_th,')',sep=''):=sapply(age_x,productFun4$endowment_A_x,moment=1,n=term))
}
knitr::kable(table_4_5_1, align = "c")
```

### §2.3.6: Ratios of Insurance Benefits

This R code snippet focuses on calculating the ratios of insurance benefits, providing insight into comparative benefit values. It computes these ratios for ages ranging from 20 to 120, considering different pairs of m-thly schedules. Using m-thly ratio schedules of (4, 1) and (12, 1), an interest rate of 5%, and an annuity schedule of 'Due', the code initializes product objects for both numerator and denominator distributions using the `discreteProducts` class. It then computes the insurance benefit ratios for each age and ratio schedule pair. The resulting ratios, indicating the relationship between benefit values for different m-thly schedules, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This highlights the application of survival models in assessing and comparing insurance benefit values, offering valuable insights for actuarial analysis and product evaluation.

Code: `table 4.6: ratios of insurance benefits appendix`

```{r table 4.6: ratios of insurance benefits,fig.align='center',echo=FALSE}
#table 4.6: ratios of insurance benefits
#-------------------------------------------------------------------------------code
#define m_thly ratio schedules, interest rate, and annuity schedule
ratio_mth <- list(c(4,1),c(12,1)); i <- .05; annuity_schedule <- 'Due' 
#define ages
age_list <- seq(20,120,20)
#initialize output table
table_4_6_1 <- data.frame(age_x=age_list)
#define case product object...m_th variation
for(m_th in ratio_mth){
  #initialize numerator product distribution
  productFun5 <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th[[1]]) 
  #initialize denominator product distribution
  productFun6 <- discreteProducts$new(i=i,annuity_schedule=annuity_schedule,m=m_th[[2]])
  #append computations to initialized output table
  table_4_6_1 <- table_4_6_1 %>%
    #compute insurance benefit ratios
    mutate(!!paste('A_x_(',m_th[[1]],') / A_x_(',m_th[[2]],')',sep='') := sapply(age_x,
                                                                                 productFun5$whole_A_x,
                                                                                 moment=1)/
                                                                            sapply(age_x,
                                                                                   productFun6$whole_A_x,
                                                                                   moment=1))
}
knitr::kable(table_4_6_1, align = "c")
```

## §2.4: Annuities
Annuities provide regular payments over the annuitant's lifetime and rely heavily on survival models and life tables for valuation. Various types of annuities (immediate, deferred, fixed, and variable) require precise calculations of expected present values to ensure they provide sufficient income streams while remaining financially sustainable.
  
### §2.4.1: Whole-Life Annuities

This R code snippet focuses on calculating whole-life annuities, providing insights into annuity values across different m-thly schedules and annuity payment timings. It computes whole-life annuities for ages ranging from 20 to 100, considering m-thly schedules of 1, 4, and 12, and both 'Due' and 'Immediate' annuity schedules. The code initializes product objects for each combination of m-thly schedule and annuity schedule using the `discreteProducts` class. It then computes the whole-life annuity values for each age and schedule combination. The resulting annuity values, representing different age groups and payment timings, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This highlights the application of survival models in assessing and comparing annuity values, offering valuable insights for actuarial analysis and financial planning.

Code: `table 5.1: whole-life annuities appendix`

```{r table 5.1: whole-life annuities,fig.align='center',echo=FALSE}
#table 5.1: whole-life annuities
#-------------------------------------------------------------------------------code
#define m_thly schedules, interest rate, and annuity schedules
m_list <- c(1,4,12); i <- .05; annuity_schedules <- c('Due','Immediate') 
#define ages 
age_list <- seq(20,100,20)
#initialize output table
table_5_1_1 <- data.frame(age_x=age_list) 
for(m_th in m_list){ #m-thly variation
  for(schedule in annuity_schedules){ #annuity schedule variation
    #define case product object...m_th and schedule variation
    productFun7 <- discreteProducts$new(i=i,annuity_schedule=schedule,m=m_th) 
    table_5_1_1 <- table_5_1_1 %>%
      #compute whole-life annuity values
      mutate(!!paste('a',substr(schedule,1,1),'_x_(',m_th,')',sep=''):=sapply(age_x,
                                                                              productFun7$whole_a_x))
}}
knitr::kable(table_5_1_1, align = "c")
```

### §2.4.2: Term Annuities

This R code snippet focuses on calculating term annuities, offering insights into annuity values for specified term periods across different m-thly schedules and annuity payment timings. It computes term annuities for ages ranging from 20 to 100 and for a term period of 10 years. Considering m-thly schedules of 1 and 4, as well as both 'Due' and 'Immediate' annuity schedules, the code initializes product objects for each combination of m-thly schedule and annuity schedule using the `discreteProducts` class. It then computes the term annuity values for each age and schedule combination. The resulting annuity values, representing different age groups, term periods, and payment timings, are compiled into a data frame and presented as a comparison table using `knitr::kable`. This highlights the application of survival models in assessing and comparing annuity values over specific term periods, offering valuable insights for actuarial analysis and financial planning.

Code: `table 5.2: term annuities appendix`

```{r table 5.2: term annuities,fig.align='center',echo=FALSE}
#table 5.2: term annuities
#-------------------------------------------------------------------------------code
#define m_thly schedules, interest rate, and annuity schedules
m_list <- c(1,4); i <- .05; annuity_schedules <- c('Due','Immediate') 
#define ages and term period
age_list <- seq(20,100,20); term <- 10
#initialize output table
table_5_2_1 <- data.frame(age_x=age_list) 
for(m_th in m_list){ #m-thly variation
  for(schedule in annuity_schedules){ #annuity schedule variation
    #define case product object...m_th and schedule variation
    productFun8 <- discreteProducts$new(i=i,annuity_schedule=schedule,m=m_th) 
    table_5_2_1 <- table_5_2_1 %>%
      #compute term annuity values
      mutate(!!paste('a',substr(schedule,1,1),'_x´_',term,'_(',m_th,')',sep=''):=sapply(age_x,
                                                                                        productFun8$term_a_x,
                                                                                        n=term))
}}
knitr::kable(table_5_2_1, align = "c")
```

### §2.4.3: Select & Ultimate Insurance Benefits and Annuities

This section delves into computing insurance benefits and annuity values, bridging select and ultimate periods while considering various advanced concepts in R programming. Initially, it establishes parameters such as m-thly schedules, interest rates, and annuity schedules, alongside age lists and terms. Employing the `discreteProducts` and `discreteProbs` classes, the code calculates insurance benefits and annuities, encompassing select and ultimate periods. Key advanced R concepts utilized include dynamic variable naming, conditional computation based on select periods, and recursive calculations to handle multiple select periods. By iteratively computing survival probabilities and benefit values, the snippet demonstrates sophisticated data manipulation techniques and showcases the integration of survival models into actuarial analysis. The resulting table presents a comprehensive overview of insurance benefits and annuities, offering valuable insights for actuarial assessments and financial planning strategies.

Code: `table 5.3: insurance benefits and annuity values appendix`

```{r table 5.3: insurance benefits and annuity values,fig.align='center',echo=FALSE}
#table 5.3: insurance benefits and annuity values
#-------------------------------------------------------------------------------code
d <- 2; age_list <- list(20,80); i <- .05; v <- 1/(1+i) #compute annual discount rate
S <- 10^5; terms <- c(5,10,20)
productFun9 <- discreteProducts$new()
probFunc4 <- discreteProbs$new()
#create data frame with desired life-table values
#define age range
table_5_3_1 <- data.frame(age_x=c((age_list[[1]]-d):(age_list[[1]]+15),
                                  (age_list[[2]]-15):age_list[[2]])) %>% 
  #define ultimate period age
  mutate(!!paste('age+',d,sep=''):=age_x+d)  %>%
  #define ultimate period life-table value
  #first-moment insurance benefit value
  mutate(!!paste('A_x+',d,sep=''):=sapply(!!sym(paste('age+',d,sep='')),
                                          productFun9$whole_A_x,
                                          moment=1)) %>%
  #second-moment insurance benefit value
  mutate(!!paste('2A_x+',d,sep=''):=sapply(!!sym(paste('age+',d,sep='')),
                                           productFun9$whole_A_x,
                                           moment=2)) %>%
  #annuity value
  mutate(!!paste('a_x+',d,sep=''):=sapply(!!sym(paste('age+',d,sep='')),
                                          productFun9$whole_a_x))
  #compute helper columns and products value
  for(select in c(1:d)){ 
    #loop through periods
    temp_name <- paste("p_[x]_",select,sep='') 
    #initialize survival feature name
    table_5_3_1 <- table_5_3_1 %>%
      #compute select period survival probabilities
      mutate(!!temp_name:=sapply(age_x,
                                 probFunc4$select_p_x_t,
                                 t=select,
                                 d=d)) 
    if (select > 1){ #setup period survival probabilities
      #initialize survival feature name...select-1
      previous_temp_name <- paste("p_[x]_",select-1,sep='') 
      #initialize survival feature name...select
      current_temp_name <- paste("p_[x]_",select,sep='') 
      #initialize survival feature name...select-1
      new_p_name <- paste("p_[x]+",select-1,"_1",sep='') 
      table_5_3_1 <- table_5_3_1 %>%
        #compute survival probabilities
        mutate(!!new_p_name:= !!sym(current_temp_name) / !!sym(previous_temp_name)) 
    }
    if (select == d){
      #assign previous and new variable names
      if(d == 1){
        #1 term select period
        previous_A_name <- 'A_x+1'; current_A_name <- 'A_[x]'
        previous_2A_name <- '2A_x+1'; current_2A_name <- '2A_[x]'
        previous_a_name <- 'a_x+1'; current_a_name <-  'a_[x]'
        #compute current variables
        current_p_name <- "p_[x]_1"
        table_5_3_1 <- table_5_3_1 %>%
          mutate(!!current_A_name := (v*(1-!!sym(current_p_name)))+(v*!!sym(current_p_name)*
                                                                      !!sym(previous_A_name))) %>%
          mutate(!!current_a_name := 1+(v*!!sym(current_p_name)*!!sym(previous_a_name))) %>%
          mutate(!!current_2A_name := ((v^2)*(1-!!sym(current_p_name)))+((v^2)*!!sym(current_p_name)*
                                                                           !!sym(previous_2A_name))) 
      }else if(d == 2){
        #2 term select period
        previous_A_name <- 'A_x+2'; current_A_name <-  'A_[x]+1'; new_A_name <- 'A_[x]'
        previous_2A_name <- '2A_x+2'; current_2A_name <-  '2A_[x]+1'; new_2A_name <- '2A_[x]'
        previous_a_name <- 'a_x+2'; current_a_name <-  'a_[x]+1'; new_a_name <- 'a_[x]'
        #compute current variables
        current_p_name <- "p_[x]+1_1"
        new_p_name <- "p_[x]_1"
        table_5_3_1 <- table_5_3_1 %>%
          #initialize first-moment benefit parameters
          mutate(!!current_A_name := (v*(1-!!sym(current_p_name)))+(v*!!sym(current_p_name)*
                                                                      !!sym(previous_A_name))) %>%
          #initialize first-moment benefit parameters
          mutate(!!new_A_name := (v*(1-!!sym(new_p_name)))+(v*!!sym(new_p_name)*!!sym(current_A_name))) %>%
          #initialize first-moment annuity parameters
          mutate(!!current_a_name := 1+(v*!!sym(current_p_name)*!!sym(previous_a_name))) %>%
          #initialize first-moment annuity parameters
          mutate(!!new_a_name := 1+(v*!!sym(new_p_name)*!!sym(current_a_name))) %>%
          #initialize second-moment benefit parameters
          mutate(!!current_2A_name := ((v^2)*(1-!!sym(current_p_name)))+((v^2)*!!sym(current_p_name)*
                                                                           !!sym(previous_2A_name))) %>%
          #initialize second-moment benefit parameters
          mutate(!!new_2A_name := ((v^2)*(1-!!sym(new_p_name)))+((v^2)*!!sym(new_p_name)*
                                                                   !!sym(current_2A_name)))
      }else if(d > 2){
        #when select period exceeds 2
        for(select2 in c((d-1):1)){
          if(select2 == d-1){
            #initialize first-moment benefit parameters
            previous_A_name <- paste('A_x+',d,sep='')
            current_A_name <- paste('A_[x]+',select2,sep='')
            #initialize second-moment benefit parameters
            previous_2A_name <- paste('2A_x+',d,sep='')
            current_2A_name <- paste('2A_[x]+',select2,sep='')
            #initialize first-moment annuity parameters
            previous_a_name <- paste('a_x+',d,sep='')
            current_a_name <- paste('a_[x]+',select2,sep='')
          }else if(select2 > 1&&select < (d-1)){
            #initialize first-moment benefit parameters
            previous_A_name <- paste('A_[x]+',select2+1,sep='')
            current_A_name <- paste('A_[x]+',select2,sep='')
            #initialize second-moment benefit parameters
            previous_2A_name <- paste('2A_[x]+',select2+1,sep='')
            current_2A_name <- paste('2A_[x]+',select2,sep='')
            #initialize first-moment annuity parameters
            previous_a_name <- paste('a_[x]+',select2+1,sep='')
            current_a_name <- paste('a_[x]+',select2,sep='')
          }else if(select2 == 1){
            #initialize first-moment benefit parameters
            previous_A_name <- paste('A_[x]+',select2+1,sep='')
            current_A_name <- 'A_[x]'
            #initialize second-moment benefit parameters
            previous_2A_name <- paste('2A_[x]+',select2+1,sep='')
            current_2A_name <- '2A_[x]'
            #initialize first-moment annuity parameters
            previous_a_name <- paste('a_[x]+',select2+1,sep='')
            current_a_name <- 'a_[x]'}
        #compute current variables
        current_p_name <- paste("p_[x]+",select2,"_1",sep='') 
        table_5_3_1 <- table_5_3_1 %>%
          #compute first-moment benefit values
          mutate(!!current_A_name := (v*(1-!!sym(current_p_name)))+(v*!!sym(current_p_name)*
                                                                      !!sym(previous_A_name))) %>%
          #compute first-moment annuity values
          mutate(!!current_a_name := 1+(v*!!sym(current_p_name)*!!sym(previous_a_name))) %>%
          #compute first-moment annuity values
          mutate(!!new_a_name := 1+(v*!!sym(new_p_name)*!!sym(current_a_name))) %>%
          #compute second-moment benefit values
          mutate(!!current_2A_name := ((v^2)*(1-!!sym(current_p_name)))+((v^2)*!!sym(current_p_name)*
                                                                           !!sym(previous_2A_name))) %>%
          #compute second-moment benefit values
          mutate(!!new_2A_name := ((v^2)*(1-!!sym(new_p_name)))+((v^2)*!!sym(new_p_name)*
                                                                   !!sym(current_2A_name)))}}}}
#query output
table_5_3_2 <- table_5_3_1 %>%
  #filter columns
  select(c('age+2','A_x+2','a_x+2','age_x','2A_[x]','A_[x]','a_[x]')) 
knitr::kable(table_5_3_2, align = "c")
```

# §3: Remarks
## §3.1: Next Steps
The next steps of the research are geared towards achieving short and long-term goals outlined in the context of the proposal. In the short term, the focus is on interacting with potential user bases and collaborators to gather insights and feedback on the proposed methodologies and techniques. This interaction serves as a vital step in validating the relevance and applicability of the research to the actuarial community. Sharing initial findings with collaborators and stakeholders allows for iterative improvements and adjustments to align the work with the actual needs and challenges faced by actuarial practitioners.

In the long term, the research aims to translate its findings into tangible outcomes that benefit both the actuarial community and broader stakeholders. One key goal is the development of ExaminationAid® dashboards, which will serve as comprehensive tools for exam preparation, educational purposes, and professional development within the actuarial science field. Additionally, the research aims to disseminate its findings through publications, contributing valuable insights to the Actuarial Science CRAN community and academic discourse. By sharing work with the CRAN community, the research seeks to foster collaboration and innovation in actuarial modeling and data science applications. Moreover, the research aims to explore other avenues where the concepts and techniques developed can be applied, potentially expanding into related fields and industries beyond actuarial science. Through these long-term goals, the research aspires to make a lasting impact on actuarial education, practice, and research, driving advancements in the field and enhancing the capabilities of actuarial professionals worldwide.

# §4: Appendix

```{r example 2.4: Gompertz survival model appendix, echo=FALSE}
cat(knitr::knit_code$get("example 2.4: Gompertz survival model"), sep = "\n")
```

```{r table 2.2: complete future life-time appendix, echo=FALSE}
cat(knitr::knit_code$get("table 2.2: complete future life-time"), sep = "\n")
```

```{r table 3.1: ultimate life-table appendix, echo=FALSE}
cat(knitr::knit_code$get("table 3.1: ultimate life-table"), sep = "\n")
```

```{r table 4.1: insurance benefits comparison appendix, echo=FALSE}
cat(knitr::knit_code$get("table 4.1: insurance benefits comparison"), sep = "\n")
```

```{r table 4.2: m-thly insurance benefits appendix, echo=FALSE}
cat(knitr::knit_code$get("table 4.2: m-thly insurance benefits"), sep = "\n")
```

```{r table 4.3: mean and standard deviation of insurance benefit EPV appendix, echo=FALSE}
cat(knitr::knit_code$get("table 4.3: mean and standard deviation of insurance benefit EPV"), sep = "\n")
```

```{r table 4.4: term insurance benefits appendix, echo=FALSE}
cat(knitr::knit_code$get("table 4.4: term insurance benefits"), sep = "\n")
```

```{r table 4.5: endowment insurance benefits appendix, echo=FALSE}
cat(knitr::knit_code$get("table 4.5: endowment insurance benefits"), sep = "\n")
```

```{r table 4.6: ratios of insurance benefits appendix, echo=FALSE}
cat(knitr::knit_code$get("table 4.6: ratios of insurance benefits"), sep = "\n")
```

```{r table 5.1: whole-life annuities appendix, echo=FALSE}
cat(knitr::knit_code$get("table 5.1: whole-life annuities"), sep = "\n")
```

```{r table 5.2: term annuities appendix, echo=FALSE}
cat(knitr::knit_code$get("table 5.2: term annuities"), sep = "\n")
```

```{r table 5.3: insurance benefits and annuity values appendix, echo=FALSE}
cat(knitr::knit_code$get("table 5.3: insurance benefits and annuity values"), sep = "\n")
```

# §5: References
```{r reference1, echo=FALSE}
print(bibentry(
     bibtype = "Manual",
     title = " CRAN Task View: Actuarial Science",
     author = as.person("Christophe Dutang [aut], Vincent Goulet [aut]"),
     year = "2024",
     publisher = "The Comprehensive R Archive Network",
     url = "https://CRAN.R-project.org/view=ActuarialScience",
     key = "actuarialDir"
   ))
```

```{r reference2, echo=FALSE}
print(bibentry(
     bibtype = "Book",
     title = "Actuarial Mathematics for Life Contingent Risks",
     author = as.person("David C.Dickson [aut], Mary R. Hardy [aut], Howard R. Waters [aut]"),
     year = "2020",
     publisher = "Cambridge University Press",
     address = "Cambridge",
     isbn = "9781108478083",
     url = "www.cambridge.org/isas",
     key = "faml"
   ))
```

```{r reference3, echo=FALSE}
print(bibentry(
     bibtype = "Book",
     title = "Advanced R",
     author = as.person("Hadley Wickham [aut]"),
     year = "2019",
     publisher = "Chapman and Hall/CRC",
     isbn = "9780815384571",
     url = "https://adv-r.hadley.nz/#welcome",
     key = "advancedR"
   ))
```